#!/usr/bin/env python3
import gzip
import os
import re
import sys
from glob import glob

"""
Rename and validate FASTQ files generated from BAM conversion using bamtofastq.
This script handles the specific output structure from bamtofastq and ensures
Cell Ranger compatibility.

bamtofastq typically creates:
- fastq_dir/run_id/run_id_S1_L001_R1_001.fastq
- fastq_dir/run_id/run_id_S1_L001_R2_001.fastq
- fastq_dir/run_id/run_id_S1_L001_I1_001.fastq (if present)
- fastq_dir/run_id/run_id_S1_L001_I2_001.fastq (if present)
"""

def estimate_read_length(fastq_path: str, n_reads: int = 1000) -> int:
    """Estimate average read length from a FASTQ file"""
    opener = gzip.open if fastq_path.endswith('.gz') else open
    length_sum = 0
    count = 0
    try:
        with opener(fastq_path, 'rt') as fh:
            while count < n_reads:
                hdr = fh.readline()
                if not hdr:
                    break
                seq = fh.readline().strip()
                plus = fh.readline()
                qual = fh.readline()
                if not qual:
                    break
                length_sum += len(seq)
                count += 1
    except Exception:
        return 0
    return int(length_sum / count) if count else 0

def validate_read_lengths(fastq_files):
    """Validate read lengths and provide warnings for common issues"""
    read_lengths = {}
    
    for fastq_file in fastq_files:
        if os.path.exists(fastq_file):
            length = estimate_read_length(fastq_file, 200)
            read_lengths[fastq_file] = length
            print(f"Read length for {os.path.basename(fastq_file)}: {length} bp", file=sys.stderr)
    
    # Check for common 10x patterns
    r1_files = [f for f in read_lengths.keys() if '_R1_' in f]
    r2_files = [f for f in read_lengths.keys() if '_R2_' in f]
    i1_files = [f for f in read_lengths.keys() if '_I1_' in f]
    i2_files = [f for f in read_lengths.keys() if '_I2_' in f]
    
    # Validate index read lengths
    for i1_file in i1_files:
        if read_lengths[i1_file] not in [8, 10, 12, 14, 16]:
            print(f"WARNING: I1 read length {read_lengths[i1_file]} bp is unusual for 10x (expected 8-16 bp)", file=sys.stderr)
    
    for i2_file in i2_files:
        if read_lengths[i2_file] not in [8, 10, 12, 14, 16]:
            print(f"WARNING: I2 read length {read_lengths[i2_file]} bp is unusual for 10x (expected 8-16 bp)", file=sys.stderr)
    
    # Validate R1 vs R2 lengths
    if r1_files and r2_files:
        r1_length = read_lengths[r1_files[0]]
        r2_length = read_lengths[r2_files[0]]
        if r1_length > r2_length:
            print(f"WARNING: R1 ({r1_length} bp) is longer than R2 ({r2_length} bp). This is unusual for 10x.", file=sys.stderr)
        elif r1_length < 20 or r2_length < 20:
            print(f"WARNING: Very short reads detected (R1: {r1_length} bp, R2: {r2_length} bp)", file=sys.stderr)

def find_bamtofastq_output(fastq_dir):
    """Find FASTQ files generated by bamtofastq (searches recursively for nested directories)"""
    fastq_files = []

    # Use recursive glob to find FASTQ files at any depth
    # bamtofastq can create multiple levels: fastq_dir/run_id/flowcell_id/*.fastq.gz
    fastq_files = glob(os.path.join(fastq_dir, "**/*.fastq"), recursive=True) + \
                  glob(os.path.join(fastq_dir, "**/*.fastq.gz"), recursive=True)

    return fastq_files

def extract_lane_number(filename):
    """Extract lane number from FASTQ filename (e.g., L001, L002, etc.)"""
    match = re.search(r'_L(\d{3})_', filename)
    return match.group(1) if match else None

def main():
    if len(sys.argv) < 4:
        print("Usage: rename_validate_bam_fastq.py <sample_id> <fastq_dir> <output_dir>", file=sys.stderr)
        sys.exit(2)
    
    sample_id = sys.argv[1]
    fastq_dir = sys.argv[2]
    output_dir = sys.argv[3]
    
    os.makedirs(output_dir, exist_ok=True)
    
    # Find all FASTQ files
    fastq_files = find_bamtofastq_output(fastq_dir)
    
    if not fastq_files:
        print(f"ERROR: No FASTQ files found in {fastq_dir}", file=sys.stderr)
        sys.exit(1)
    
    print(f"Found {len(fastq_files)} FASTQ files", file=sys.stderr)
    
    # Validate read lengths
    validate_read_lengths(fastq_files)
    
    # Process each FASTQ file - preserve lane numbers to avoid header mismatches
    written_files = []
    for fastq_file in fastq_files:
        filename = os.path.basename(fastq_file)

        # Extract read type from filename (R1, R2, I1, I2)
        read_type = None
        if '_R1_' in filename:
            read_type = 'R1'
        elif '_R2_' in filename:
            read_type = 'R2'
        elif '_I1_' in filename:
            read_type = 'I1'
        elif '_I2_' in filename:
            read_type = 'I2'

        if not read_type:
            print(f"WARNING: Could not determine read type for {filename}", file=sys.stderr)
            continue

        # Extract lane number to preserve it (critical for paired-end matching)
        lane = extract_lane_number(filename)
        if not lane:
            print(f"WARNING: Could not extract lane number from {filename}, using L001", file=sys.stderr)
            lane = "001"

        # Create output filename with preserved lane number
        output_filename = f"{sample_id}_S1_L{lane}_{read_type}_001.fastq.gz"
        output_path = os.path.join(output_dir, output_filename)

        # Copy and gzip if needed
        if fastq_file.endswith('.gz'):
            # Already gzipped, just copy
            with open(fastq_file, 'rb') as src, open(output_path, 'wb') as dst:
                dst.write(src.read())
        else:
            # Need to gzip
            with open(fastq_file, 'rb') as src, gzip.open(output_path, 'wb') as dst:
                dst.write(src.read())

        written_files.append(output_path)
        print(f"Created: {output_filename}", file=sys.stderr)
    
    # Print resulting files for Nextflow collection
    for f in written_files:
        print(f)
    
    if not written_files:
        print("ERROR: No valid FASTQ files were processed", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
